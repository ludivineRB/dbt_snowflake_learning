---
title: Module 3 - TF-IDF DÃ©monstrations
description: Formation NLP - Module 3 - TF-IDF DÃ©monstrations
tags:
  - NLP
  - 09-Deep-Learning
category: 09-Deep-Learning
---

# âš–ï¸ TF-IDF - DÃ©monstrations Interactives

ExpÃ©rimentez avec le calcul et les applications du TF-IDF

[â† Concepts TF-IDF](module3_tfidf_concepts.html) [N-grams â†’](module3_ngrams_concepts.html) [ğŸ  Index Module 3](module3_index.html)

## ğŸ§® Calculateur TF-IDF Interactif

ğŸ¯ Calcul Basique âš™ï¸ Options AvancÃ©es ğŸ“‹ Ã‰tape par Ã‰tape

### âœï¸ Entrez vos documents (un par ligne) :

Le machine learning transforme l'intelligence artificielle Les algorithmes d'apprentissage automatique sont puissants Le deep learning utilise des rÃ©seaux de neurones L'intelligence artificielle rÃ©volutionne de nombreux domaines âš–ï¸ Calculer TF-IDF

Cliquez sur "Calculer TF-IDF" pour voir les rÃ©sultats...

0

Documents

0

Mots Uniques

0.000

TF-IDF Moyen

0.000

TF-IDF Max

### âš™ï¸ Configuration AvancÃ©e TF-IDF :

L'intelligence artificielle rÃ©volutionne le secteur de la santÃ© Le machine learning permet des diagnostics plus prÃ©cis Les algorithmes de deep learning analysent les images mÃ©dicales La data science exploite les donnÃ©es cliniques massives L'IA conversationnelle amÃ©liore l'interaction patient-mÃ©decin

SchÃ©ma TF : NormalisÃ© (dÃ©faut) Comptage brut Logarithmique BoolÃ©en

SchÃ©ma IDF : Standard Smooth (+1) IDF Max

 Normalisation L2

Seuil d'affichage : 

ğŸ”§ Calculer TF-IDF AvancÃ©

Configurez les options et calculez...

### ğŸ“‹ Calcul DÃ©taillÃ© Ã‰tape par Ã‰tape

Entrez un petit corpus pour voir chaque Ã©tape du calcul :

Python machine learning Java dÃ©veloppement web Machine learning intelligence artificielle ğŸ“‹ Calcul DÃ©taillÃ©

Calcul Ã©tape par Ã©tape apparaÃ®tra ici...

## ğŸ”‘ Extracteur de Mots-ClÃ©s TF-IDF

### ğŸ“„ Texte Ã  analyser :

L'intelligence artificielle rÃ©volutionne le secteur de la santÃ© en permettant des diagnostics plus prÃ©cis et rapides. Les algorithmes de machine learning analysent des millions de donnÃ©es mÃ©dicales pour identifier des patterns invisibles Ã  l'Å“il humain. Les radiologues utilisent maintenant des outils d'IA pour dÃ©tecter les cancers plus efficacement. Cette technologie transforme Ã©galement la recherche pharmaceutique en accÃ©lÃ©rant la dÃ©couverte de nouveaux mÃ©dicaments. Les hÃ´pitaux intÃ¨grent progressivement ces solutions innovantes pour amÃ©liorer les soins aux patients et optimiser leurs processus internes.

Nombre de mots-clÃ©s : 

 Exclure les mots vides

Longueur min. mot : 

ğŸ”‘ Extraire Mots-ClÃ©s

Mots-clÃ©s extraits apparaÃ®tront ici...

## ğŸ” Moteur de Recherche TF-IDF

### ğŸ“š Base de documents :

Doc1: Machine learning rÃ©volutionne l'analyse de donnÃ©es massives Doc2: Intelligence artificielle transforme les entreprises modernes Doc3: Python simplifie le dÃ©veloppement d'applications web Doc4: Deep learning amÃ©liore la reconnaissance d'images Doc5: Data science exploite les algorithmes d'apprentissage Doc6: RÃ©seaux de neurones imitent le fonctionnement du cerveau Doc7: Big data nÃ©cessite des outils de traitement spÃ©cialisÃ©s Doc8: Cloud computing facilite l'accÃ¨s aux ressources

### ğŸ” Votre recherche :

Nombre de rÃ©sultats : 

Seuil de similaritÃ© : 

ğŸ” Rechercher

RÃ©sultats de recherche apparaÃ®tront ici...

## âš”ï¸ Comparaison BoW vs TF-IDF

### ğŸ§ª Test Comparatif :

Les spÃ©cialistes en intelligence artificielle dÃ©veloppent des algorithmes avancÃ©s. Les dÃ©veloppeurs utilisent Python pour programmer des applications modernes. L'intelligence artificielle transforme les mÃ©thodes de dÃ©veloppement logiciel. Python facilite l'implÃ©mentation d'algorithmes de machine learning. Les algorithmes d'apprentissage automatique rÃ©volutionnent l'industrie. âš”ï¸ Comparer BoW vs TF-IDF

Comparaison apparaÃ®tra ici...

**ğŸ“Š Qu'observe-t-on ?**  
â€¢ **BoW** : PrivilÃ©gie les mots frÃ©quents dans chaque document  
â€¢ **TF-IDF** : Valorise les mots rares et discriminants  
â€¢ **RÃ©sultat** : TF-IDF est plus efficace pour identifier les thÃ¨mes spÃ©cifiques

## ğŸ’¼ Applications Pratiques

### ğŸ¯ Classification de Documents

Testez la classification avec TF-IDF :

#### ğŸ“š Documents d'entraÃ®nement :

TECH: Python machine learning IA dÃ©veloppement algorithmes SPORT: Football Ã©quipe joueur match victoire championnat SANTE: MÃ©decin patient traitement hÃ´pital diagnostic TECH: JavaScript web application programmation software SPORT: Tennis tournoi joueur raquette court victoire SANTE: Chirurgie opÃ©ration patient mÃ©decin clinique

#### ğŸ§ª Document Ã  classer :

Les dÃ©veloppeurs utilisent Python pour crÃ©er des applications d'intelligence artificielle sophistiquÃ©es

ğŸ¯ Classifier

RÃ©sultat de classification...

### ğŸ“ˆ Analyse de Performance

Comparez les performances TF-IDF selon diffÃ©rents paramÃ¨tres :

Intelligence artificielle rÃ©volutionne secteur mÃ©dical Python dÃ©veloppement applications web modernes Machine learning analyse donnÃ©es clients Blockchain technologie sÃ©curise transactions Cloud computing optimise infrastructures

Max features : 1000 3000 5000 10000

Min DF : 1 2 3

ğŸ“ˆ Analyser Performance

Analyse de performance...

[â† Concepts TF-IDF](module3_tfidf_concepts.html) [N-grams â†’](module3_ngrams_concepts.html) [ğŸ  Index Module 3](module3_index.html)

// Variables globales let currentTFIDFMatrix = null; let currentVocab = null; // Stopwords franÃ§ais const STOPWORDS\_FR = new Set(\[ 'le', 'de', 'et', 'Ã ', 'un', 'il', 'Ãªtre', 'en', 'avoir', 'que', 'pour', 'dans', 'ce', 'son', 'une', 'sur', 'avec', 'ne', 'se', 'pas', 'tout', 'plus', 'par', 'grand', 'son', 'que', 'ce', 'lui', 'au', 'du', 'des', 'la', 'les', 'est', 'cette', 'ces', 'mais', 'ou', 'si', 'nous', 'vous', 'ils', 'elles', 'aussi', 'trÃ¨s', 'bien', 'comme', 'donc', 'peut', 'fait', 'sans' \]); // Gestion des onglets function openTab(evt, tabName) { var i, tabcontent, tabs; tabcontent = document.getElementsByClassName("tab-content"); for (i = 0; i < tabcontent.length; i++) { tabcontent\[i\].classList.remove("active"); } tabs = document.getElementsByClassName("tab"); for (i = 0; i < tabs.length; i++) { tabs\[i\].classList.remove("active"); } document.getElementById(tabName).classList.add("active"); evt.currentTarget.classList.add("active"); } // Preprocessing du texte function preprocessText(text, removeStopwords = true) { let processed = text.toLowerCase(); processed = processed.replace(/\[^\\w\\s\]/g, ' '); let tokens = processed.split(/\\s+/).filter(token => token.length > 0); if (removeStopwords) { tokens = tokens.filter(token => !STOPWORDS\_FR.has(token)); } return tokens; } // Calcul TF-IDF basique function calculateBasicTFIDF() { const text = document.getElementById('tfidfInput').value.trim(); if (!text) { document.getElementById('basicTFIDFResult').textContent = 'Veuillez entrer des documents !'; return; } const docs = text.split('\\n').filter(doc => doc.trim()); const result = computeTFIDF(docs); displayTFIDFResult(result, 'basicTFIDFResult'); updateTFIDFStats(result); } // Calcul TF-IDF avancÃ© function calculateAdvancedTFIDF() { const text = document.getElementById('advancedInput').value.trim(); if (!text) { document.getElementById('advancedResult').textContent = 'Veuillez entrer des documents !'; return; } const docs = text.split('\\n').filter(doc => doc.trim()); const options = { tfScheme: document.getElementById('tfScheme').value, idfScheme: document.getElementById('idfScheme').value, normalizeL2: document.getElementById('normalizeL2').checked, threshold: parseFloat(document.getElementById('displayThreshold').value) }; const result = computeTFIDF(docs, options); displayTFIDFResult(result, 'advancedResult', options); } // Calcul Ã©tape par Ã©tape function calculateStepByStep() { const text = document.getElementById('stepByStepInput').value.trim(); if (!text) { document.getElementById('stepByStepResult').textContent = 'Veuillez entrer des documents !'; return; } const docs = text.split('\\n').filter(doc => doc.trim()); let html = \`<strong>ğŸ“‹ CALCUL TF-IDF Ã‰TAPE PAR Ã‰TAPE</strong>\\n\`; html += '=' \* 50 + '\\n\\n'; // Ã‰tape 1: Preprocessing const processedDocs = docs.map(doc => preprocessText(doc)); html += \`<strong>1ï¸âƒ£ PREPROCESSING :</strong>\\n\`; processedDocs.forEach((tokens, i) => { html += \`Doc ${i+1}: \[${tokens.join(', ')}\]\\n\`; }); // Ã‰tape 2: Vocabulaire const vocab = \[...new Set(processedDocs.flat())\].sort(); html += \`\\n<strong>2ï¸âƒ£ VOCABULAIRE (${vocab.length} mots) :</strong>\\n\`; html += vocab.join(', ') + '\\n'; // Ã‰tape 3: Calcul TF html += '\\n<strong>3ï¸âƒ£ CALCUL TERM FREQUENCY (TF) :</strong>\\n'; const tfMatrix = processedDocs.map((tokens, docIdx) => { html += \`\\nDoc ${docIdx + 1} (${tokens.length} mots) :\\n\`; const tf = {}; vocab.forEach(word => { const count = tokens.filter(t => t === word).length; tf\[word\] = count / tokens.length; if (count > 0) { html += \` TF("${word}") = ${count}/${tokens.length} = ${tf\[word\].toFixed(3)}\\n\`; } }); return tf; }); // Ã‰tape 4: Calcul IDF html += '\\n<strong>4ï¸âƒ£ CALCUL INVERSE DOCUMENT FREQUENCY (IDF) :</strong>\\n'; const N = docs.length; const idf = {}; vocab.forEach(word => { const df = processedDocs.filter(tokens => tokens.includes(word)).length; idf\[word\] = Math.log(N / df); html += \`IDF("${word}") = log(${N}/${df}) = ${idf\[word\].toFixed(3)}\\n\`; }); // Ã‰tape 5: Calcul TF-IDF final html += '\\n<strong>5ï¸âƒ£ CALCUL TF-IDF FINAL :</strong>\\n'; processedDocs.forEach((tokens, docIdx) => { html += \`\\nDoc ${docIdx + 1} - Top mots importants :\\n\`; const docTFIDF = \[\]; vocab.forEach(word => { const tfValue = tfMatrix\[docIdx\]\[word\]; const idfValue = idf\[word\]; const tfidfValue = tfValue \* idfValue; if (tfidfValue > 0) { docTFIDF.push({word, tfidf: tfidfValue, tf: tfValue, idf: idfValue}); } }); docTFIDF.sort((a, b) => b.tfidf - a.tfidf); docTFIDF.slice(0, 5).forEach(item => { html += \` "${item.word}": ${item.tf.toFixed(3)} Ã— ${item.idf.toFixed(3)} = ${item.tfidf.toFixed(3)}\\n\`; }); }); document.getElementById('stepByStepResult').textContent = html; } // Fonction principale de calcul TF-IDF function computeTFIDF(docs, options = {}) { const opts = { tfScheme: 'normalized', idfScheme: 'standard', normalizeL2: true, threshold: 0.01, ...options }; // Preprocessing const processedDocs = docs.map(doc => preprocessText(doc)); const vocab = \[...new Set(processedDocs.flat())\].sort(); // Calcul IDF const N = docs.length; const idf = {}; vocab.forEach(word => { const df = processedDocs.filter(tokens => tokens.includes(word)).length; if (opts.idfScheme === 'smooth') { idf\[word\] = Math.log(N / (df + 1)) + 1; } else if (opts.idfScheme === 'max') { const maxDf = Math.max(...vocab.map(w => processedDocs.filter(tokens => tokens.includes(w)).length)); idf\[word\] = Math.log(maxDf / df); } else { // standard idf\[word\] = Math.log(N / df); } }); // Calcul TF-IDF const matrix = processedDocs.map(tokens => { const docLength = tokens.length; const tfidf = {}; vocab.forEach(word => { const count = tokens.filter(t => t === word).length; let tf = 0; if (opts.tfScheme === 'raw') { tf = count; } else if (opts.tfScheme === 'normalized') { tf = docLength > 0 ? count / docLength : 0; } else if (opts.tfScheme === 'log') { tf = count > 0 ? 1 + Math.log(count) : 0; } else if (opts.tfScheme === 'boolean') { tf = count > 0 ? 1 : 0; } tfidf\[word\] = tf \* idf\[word\]; }); // Normalisation L2 if (opts.normalizeL2) { const norm = Math.sqrt(Object.values(tfidf).reduce((sum, val) => sum + val \* val, 0)); if (norm > 0) { Object.keys(tfidf).forEach(word => { tfidf\[word\] /= norm; }); } } return tfidf; }); return { docs, processedDocs, vocab, idf, matrix, options: opts }; } // Affichage des rÃ©sultats TF-IDF function displayTFIDFResult(result, targetId, options = {}) { let html = \`<strong>âš–ï¸ RÃ‰SULTATS TF-IDF</strong>\\n\`; html += '=' \* 35 + '\\n\\n'; if (options.tfScheme) { html += \`<strong>âš™ï¸ Configuration :</strong>\\n\`; html += \`- SchÃ©ma TF: ${options.tfScheme}\\n\`; html += \`- SchÃ©ma IDF: ${options.idfScheme}\\n\`; html += \`- Normalisation L2: ${options.normalizeL2}\\n\`; html += \`- Seuil: ${options.threshold}\\n\\n\`; } html += \`<strong>ğŸ“š Vocabulaire :</strong> ${result.vocab.length} mots\\n\`; html += \`<strong>ğŸ“„ Documents :</strong> ${result.docs.length}\\n\\n\`; // Top mots par document result.matrix.forEach((docTFIDF, docIdx) => { html += \`<strong>ğŸ“„ Document ${docIdx + 1}:</strong> "${result.docs\[docIdx\].substring(0, 50)}..."\\n\`; const sortedWords = Object.entries(docTFIDF) .filter((\[word, score\]) => score >= (options.threshold || 0.01)) .sort((a, b) => b\[1\] - a\[1\]); html += 'Top mots importants :\\n'; sortedWords.slice(0, 8).forEach((\[word, score\]) => { html += \` "${word}": ${score.toFixed(3)}\\n\`; }); html += '\\n'; }); document.getElementById(targetId).textContent = html; // Sauvegarder pour autres fonctions currentTFIDFMatrix = result.matrix; currentVocab = result.vocab; } // Mise Ã  jour des statistiques function updateTFIDFStats(result) { const allValues = result.matrix.flatMap(doc => Object.values(doc)).filter(v => v > 0); const avgTFIDF = allValues.length > 0 ? allValues.reduce((sum, val) => sum + val, 0) / allValues.length : 0; const maxTFIDF = Math.max(...allValues, 0); document.getElementById('totalDocs').textContent = result.docs.length; document.getElementById('uniqueWords').textContent = result.vocab.length; document.getElementById('avgTFIDF').textContent = avgTFIDF.toFixed(3); document.getElementById('maxTFIDF').textContent = maxTFIDF.toFixed(3); document.getElementById('tfidfStats').style.display = 'grid'; } // Extraction de mots-clÃ©s function extractKeywords() { const text = document.getElementById('keywordInput').value.trim(); if (!text) { document.getElementById('keywordResult').textContent = 'Veuillez entrer du texte !'; return; } const numKeywords = parseInt(document.getElementById('numKeywords').value); const removeStopwords = document.getElementById('removeStopwords').checked; const minLength = parseInt(document.getElementById('minWordLength').value); // Diviser le texte en phrases pour simuler plusieurs documents const sentences = text.split(/\[.!?\]+/).filter(s => s.trim()); if (sentences.length < 2) { document.getElementById('keywordResult').textContent = 'Le texte doit contenir plusieurs phrases !'; return; } const result = computeTFIDF(sentences, {normalizeL2: true}); // Calculer le score TF-IDF global pour chaque mot const globalScores = {}; result.vocab.forEach(word => { globalScores\[word\] = result.matrix.reduce((sum, doc) => sum + doc\[word\], 0); }); // Filtrer et trier let keywords = Object.entries(globalScores) .filter((\[word, score\]) => word.length >= minLength) .sort((a, b) => b\[1\] - a\[1\]) .slice(0, numKeywords); let html = \`<strong>ğŸ”‘ MOTS-CLÃ‰S EXTRAITS (Top ${numKeywords})</strong>\\n\`; html += '=' \* 45 + '\\n\\n'; html += \`<strong>ğŸ“ Texte analysÃ© :</strong> ${text.length} caractÃ¨res, ${sentences.length} phrases\\n\`; html += \`<strong>ğŸ“Š Vocabulaire :</strong> ${result.vocab.length} mots uniques\\n\\n\`; html += \`<strong>ğŸ† Mots-clÃ©s les plus importants :</strong>\\n\`; keywords.forEach((\[word, score\], index) => { const medal = index < 3 ? \['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'\]\[index\] : \`${index + 1}.\`; html += \`${medal} "${word}" (score: ${score.toFixed(3)})\\n\`; }); document.getElementById('keywordResult').textContent = html; // Affichage visuel des mots-clÃ©s const displayDiv = document.getElementById('keywordDisplay'); displayDiv.innerHTML = keywords.map((\[word, score\]) => \`<span class="keyword-tag">${word}<span class="keyword-score">${score.toFixed(3)}</span></span>\` ).join(''); displayDiv.style.display = 'flex'; } // Recherche par similaritÃ© function searchSimilarity() { const corpusText = document.getElementById('searchCorpus').value.trim(); const query = document.getElementById('searchQuery').value.trim(); if (!query) { document.getElementById('searchResults').textContent = 'Veuillez entrer une requÃªte !'; return; } const numResults = parseInt(document.getElementById('numResults').value); const threshold = parseFloat(document.getElementById('similarityThreshold').value); // Extraire les documents const docs = corpusText.split('\\n').map(line => { const colonIndex = line.indexOf(':'); return colonIndex > 0 ? line.substring(colonIndex + 1).trim() : line.trim(); }).filter(doc => doc); // Ajouter la requÃªte comme dernier document const allDocs = \[...docs, query\]; const result = computeTFIDF(allDocs); // Calculer la similaritÃ© cosinus entre la requÃªte et chaque document const queryVector = result.matrix\[result.matrix.length - 1\]; const similarities = \[\]; for (let i = 0; i < docs.length; i++) { const docVector = result.matrix\[i\]; const similarity = cosineSimilarity(queryVector, docVector, result.vocab); if (similarity >= threshold) { similarities.push({ index: i, doc: docs\[i\], similarity: similarity }); } } // Trier par similaritÃ© dÃ©croissante similarities.sort((a, b) => b.similarity - a.similarity); let html = \`<strong>ğŸ” RÃ‰SULTATS DE RECHERCHE</strong>\\n\`; html += '=' \* 35 + '\\n\\n'; html += \`<strong>ğŸ” RequÃªte :</strong> "${query}"\\n\`; html += \`<strong>ğŸ“š Corpus :</strong> ${docs.length} documents\\n\`; html += \`<strong>ğŸ¯ Seuil :</strong> ${threshold}\\n\`; html += \`<strong>ğŸ“Š TrouvÃ©s :</strong> ${similarities.length} documents\\n\\n\`; if (similarities.length === 0) { html += \`âŒ Aucun document ne dÃ©passe le seuil de similaritÃ© de ${threshold}\\n\`; html += \`ğŸ’¡ Essayez de rÃ©duire le seuil ou modifier votre requÃªte\`; } else { html += \`<strong>ğŸ† Top ${Math.min(numResults, similarities.length)} rÃ©sultats :</strong>\\n\`; similarities.slice(0, numResults).forEach((result, index) => { const medal = index < 3 ? \['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰'\]\[index\] : \`${index + 1}.\`; html += \`\\n${medal} SimilaritÃ©: ${(result.similarity \* 100).toFixed(1)}%\\n\`; html += \` "${result.doc}"\\n\`; }); } document.getElementById('searchResults').textContent = html; } // Calcul de similaritÃ© cosinus function cosineSimilarity(vectorA, vectorB, vocab) { let dotProduct = 0; let normA = 0; let normB = 0; vocab.forEach(word => { const a = vectorA\[word\] || 0; const b = vectorB\[word\] || 0; dotProduct += a \* b; normA += a \* a; normB += b \* b; }); const denominator = Math.sqrt(normA) \* Math.sqrt(normB); return denominator > 0 ? dotProduct / denominator : 0; } // Comparaison BoW vs TF-IDF function compareBowTFIDF() { const text = document.getElementById('comparisonInput').value.trim(); if (!text) { document.getElementById('comparisonResult').textContent = 'Veuillez entrer du texte !'; return; } const docs = text.split('\\n').filter(doc => doc.trim()); // Calcul BoW (comptages simples) const processedDocs = docs.map(doc => preprocessText(doc)); const vocab = \[...new Set(processedDocs.flat())\].sort(); const bowMatrix = processedDocs.map(tokens => { const counts = {}; vocab.forEach(word => { counts\[word\] = tokens.filter(t => t === word).length; }); return counts; }); // Calcul TF-IDF const tfidfResult = computeTFIDF(docs); let html = \`<strong>âš”ï¸ COMPARAISON BOW vs TF-IDF</strong>\\n\`; html += '=' \* 45 + '\\n\\n'; // Analyse comparative pour chaque document processedDocs.forEach((tokens, docIdx) => { html += \`<strong>ğŸ“„ Document ${docIdx + 1}:</strong> "${docs\[docIdx\].substring(0, 40)}..."\\n\`; // Top mots BoW const bowTop = Object.entries(bowMatrix\[docIdx\]) .filter((\[word, count\]) => count > 0) .sort((a, b) => b\[1\] - a\[1\]) .slice(0, 5); // Top mots TF-IDF const tfidfTop = Object.entries(tfidfResult.matrix\[docIdx\]) .filter((\[word, score\]) => score > 0) .sort((a, b) => b\[1\] - a\[1\]) .slice(0, 5); html += \`BoW Top 5 : ${bowTop.map((\[w, c\]) => \`${w}(${c})\`).join(', ')}\\n\`; html += \`TF-IDF Top 5 : ${tfidfTop.map((\[w, s\]) => \`${w}(${s.toFixed(3)})\`).join(', ')}\\n\\n\`; }); html += \`<strong>ğŸ” OBSERVATIONS :</strong>\\n\`; html += \`â€¢ BoW privilÃ©gie les mots frÃ©quents dans chaque document\\n\`; html += \`â€¢ TF-IDF valorise les mots rares et discriminants\\n\`; html += \`â€¢ TF-IDF est plus efficace pour identifier les thÃ¨mes spÃ©cifiques\\n\`; html += \`â€¢ BoW peut Ãªtre dominÃ© par des mots communs peu informatifs\`; document.getElementById('comparisonResult').textContent = html; } // Classification de documents function classifyDocument() { const trainText = document.getElementById('trainDocs').value.trim(); const testText = document.getElementById('testDoc').value.trim(); if (!testText) { document.getElementById('classificationResult').textContent = 'Veuillez entrer un document Ã  classifier !'; return; } // Parser les documents d'entraÃ®nement const trainDocs = trainText.split('\\n').map(line => { const colonIndex = line.indexOf(':'); return { label: line.substring(0, colonIndex).trim(), content: line.substring(colonIndex + 1).trim() }; }); // CrÃ©er les profils par catÃ©gorie avec TF-IDF const allDocs = trainDocs.map(doc => doc.content).concat(\[testText\]); const result = computeTFIDF(allDocs); // Moyenner les profils par catÃ©gorie const categoryProfiles = {}; trainDocs.forEach((doc, idx) => { if (!categoryProfiles\[doc.label\]) { categoryProfiles\[doc.label\] = {}; } result.vocab.forEach(word => { if (!categoryProfiles\[doc.label\]\[word\]) { categoryProfiles\[doc.label\]\[word\] = 0; } categoryProfiles\[doc.label\]\[word\] += result.matrix\[idx\]\[word\]; }); }); // Normaliser les profils Object.keys(categoryProfiles).forEach(label => { const count = trainDocs.filter(doc => doc.label === label).length; result.vocab.forEach(word => { categoryProfiles\[label\]\[word\] /= count; }); }); // Calculer la similaritÃ© avec le document test const testVector = result.matrix\[result.matrix.length - 1\]; const similarities = {}; Object.entries(categoryProfiles).forEach((\[label, profile\]) => { similarities\[label\] = cosineSimilarity(testVector, profile, result.vocab); }); // PrÃ©diction const predicted = Object.entries(similarities).sort((a, b) => b\[1\] - a\[1\]); let html = \`<strong>ğŸ¯ CLASSIFICATION AVEC TF-IDF</strong>\\n\`; html += '=' \* 40 + '\\n\\n'; html += \`<strong>ğŸ“„ Document test :</strong>\\n"${testText}"\\n\\n\`; html += \`<strong>ğŸ“Š Scores de similaritÃ© :</strong>\\n\`; predicted.forEach((\[label, score\], index) => { const percentage = (score \* 100).toFixed(1); const bar = 'â–ˆ'.repeat(Math.round(score \* 20)); const prediction = index === 0 ? ' â† PRÃ‰DICTION' : ''; html += \`${label.padEnd(8)} : ${bar.padEnd(20)} ${percentage}%${prediction}\\n\`; }); html += \`\\n<strong>ğŸ† CatÃ©gorie prÃ©dite :</strong> ${predicted\[0\]\[0\].toUpperCase()}\\n\`; html += \`<strong>ğŸ“ˆ Confiance :</strong> ${(predicted\[0\]\[1\] \* 100).toFixed(1)}%\`; document.getElementById('classificationResult').textContent = html; } // Analyse de performance function analyzePerformance() { const text = document.getElementById('performanceInput').value.trim(); if (!text) { document.getElementById('performanceResult').textContent = 'Veuillez entrer du corpus !'; return; } const docs = text.split('\\n').filter(doc => doc.trim()); const maxFeatures = parseInt(document.getElementById('maxFeatures').value); const minDF = parseInt(document.getElementById('minDF').value); let html = \`<strong>ğŸ“ˆ ANALYSE DE PERFORMANCE TF-IDF</strong>\\n\`; html += '=' \* 45 + '\\n\\n'; html += \`<strong>ğŸ“Š Corpus analysÃ© :</strong>\\n\`; html += \` Documents : ${docs.length}\\n\`; html += \` CaractÃ¨res totaux : ${docs.join('').length}\\n\`; html += \` Mots moyens/doc : ${Math.round(docs.reduce((sum, doc) => sum + doc.split(' ').length, 0) / docs.length)}\\n\\n\`; // Test avec diffÃ©rentes configurations const configs = \[ {name: 'Standard', maxFeatures: 1000, minDF: 1}, {name: 'OptimisÃ©', maxFeatures: maxFeatures, minDF: minDF}, {name: 'Complet', maxFeatures: 10000, minDF: 1} \]; html += \`<strong>âš™ï¸ COMPARAISON CONFIGURATIONS :</strong>\\n\`; html += \`Configuration Vocabulaire Temps SparsitÃ©\\n\`; html += \`-\`.repeat(50) + '\\n'; configs.forEach(config => { const startTime = performance.now(); const result = computeTFIDF(docs, {}); const endTime = performance.now(); const time = (endTime - startTime).toFixed(1); const vocabSize = result.vocab.length; // Calculer la sparsitÃ© const totalValues = result.matrix.length \* result.vocab.length; const zeroValues = result.matrix.reduce((sum, doc) => { return sum + result.vocab.filter(word => doc\[word\] === 0).length; }, 0); const sparsity = ((zeroValues / totalValues) \* 100).toFixed(1); html += \`${config.name.padEnd(12)} ${vocabSize.toString().padEnd(9)} ${time.padEnd(6)}ms ${sparsity}%\\n\`; }); html += \`\\n<strong>ğŸ’¡ RECOMMANDATIONS :</strong>\\n\`; html += \`âœ… max\_features: Commencer avec 3000-5000\\n\`; html += \`âœ… min\_df: Utiliser 2-3 pour filtrer le bruit\\n\`; html += \`âœ… TF-IDF gÃ©nÃ©ralement > BoW pour classification\\n\`; html += \`âš ï¸ Attention Ã  l'overfitting avec trop de features\`; document.getElementById('performanceResult').textContent = html; } // Initialisation window.addEventListener('load', function() { // Animation des sections const sections = document.querySelectorAll('.section'); sections.forEach((section, index) => { setTimeout(() => { section.style.opacity = '1'; section.style.transform = 'translateY(0)'; }, index \* 200); }); });
